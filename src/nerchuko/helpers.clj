(ns nerchuko.helpers
  "Functions that help with various auxiliary tasks such
as converting documents to the necessary format etc."
  (:use nerchuko.utils
        clj-text.tokenization)
  (:use [clojure.contrib.duck-streams :only (spit)]))

(defn save-model
  "Saves model to a file."
  [file model]
  (binding [*print-dup* true]
    (spit file
          (pr-str (merge {} model)))))

(defn load-model
  "Load model from a file."
  [file]
  (read-string (slurp file)))

(defstruct
    #^{:doc "A structure basis for a model generated by
a classifier.
:classifier  A symbol representing the namespace of the
             classifier used to generate the model.
:classes     A set of all the classes.
:features    A set of all the features."}
  model
  :classifier :classes :features)

(defmulti
  #^{:arglists '([doc])
     :doc      "Returns a document that can be used as an
input to the nerchuko classification/feature-selection functions.
The returned doc is a map with the features as the keys and the
number of occurrences of those features as the values.
What the features are depends on what doc is to begin with:

java.lang.String:
    The string is tokenized (using clj.text.tokenization/tokenize)
    and the tokens become the features. The number of times each
    token occurs in the string is the corresponding value.

java.util.Collection (vectors, lists, sets etc.):
    Each item in the seq is treated as a feature and the number of
    occurrences of each token is the corresponding value.

java.util.Map:
    First, all the string vals are tokenized. Then
    nerchuko.utils/flatten-map is called to obtain a seq.
    prepare-doc is recursively called on this to get the final
    return value.
    But, if doc's metadata has the key :prepared set to true,
    the doc is returned unmodified."}
  prepare-doc class)

(defmethod prepare-doc String [doc]
  (prepare-doc (tokenize doc)))

(defmethod prepare-doc java.util.Map [doc]
  (if (:prepared (meta doc))
    doc
    (->> doc
         (map (fn [[key val]]
                (if (string? val)
                  {key (tokenize val)}
                  {key val})))
         (reduce merge)
         flatten-map
         prepare-doc)))

(defmethod prepare-doc java.util.Collection [doc]
  (with-meta (counts doc)
    {:prepared true}))

(defn prepare-dataset
  "Calls prepare-doc on every doc in the dataset.
Returns a dataset with all the documents prepared."
  [dataset]
  (if (:prepared? (meta dataset))
    dataset
    (map-on-firsts prepare-doc
                   dataset)))
