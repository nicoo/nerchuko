(ns nerchuko.helpers
  "Functions that help with various auxiliary tasks such
as converting documents to the necessary format etc."
  (:use nerchuko.utils
        clj-text.tokenization)
  (:use [clojure.contrib.duck-streams :only (spit)]
        clojure.contrib.generic.functor))

(defn save-model
  "Saves model to a file."
  [file model]
  (binding [*print-dup* true]
    (spit file
          (pr-str (merge {} model)))))

(defn load-model
  "Load model from a file."
  [file]
  (read-string (slurp file)))

(defstruct
    #^{:doc "A structure basis for a model generated by
a classifier.
:classifier  A symbol representing the namespace of the
             classifier used to generate the model.
:classes     A set of all the classes.
:features    A set of all the features."}
  model
  :classifier :classes :features)

(defmulti
  #^{:arglists '([coll-or-obj])
     :doc "Creates a bag (multiset) from coll. It is represented
simply as a map of the elements to the number times they appear.

The exact way in which the bag is constructed depends on the type of
coll-or-obj.

nil: An empty bag (an empty map) is returned.

Vector/List/Set/etc.: Each item in the coll is treated as an element
    of the bag.

Map: First, all the vals are converted to a bag. Next, the elements of
    these bags are modified by prefixing them with the corresponding
    key in the original map. All the resulting bags are then merged
    together to form the final result.

Other: {coll-or-obj 1} is returned.

Examples:

    [:a 19 :b 67 :b :a :a]
  becomes:
    {:a 3, :b 2, 19 1, 67 1}

    42
  becomes:
    {42 1}

    \"pheonix\"
  becomes:
    {\"phoenix\" 1}

    (new Object)
  becomes:
    {#<Object java.lang.Object@1d4ee7e> 1}

    {:a 42
     :b \"hello\"
     :c [\"hello\" \"world\" \"hello\"]}
  first becomes (intermediate value):
    {:a {42 1}
     :b {\"hello\" 1}
     :c {\"hello\" 2 \"world\" 1]}
  and finally:
    {[:a 42] 1
     [:b \"hello\"] 1
     [:c \"hello\"] 2
     [:c \"world\"] 1}"}
  bag type)

(defmethod bag :default [x]
  {x 1})

(defmethod bag nil [_]
  {})

(defmethod bag java.util.Collection [coll]
  (counts coll))

(defmethod bag java.util.Map
  ([m]
     (let [prefix-keys (fn [prefix m]   ; prefixes each key of m with
                                        ; prefix i.e. [prefix key]
                         (map-keys #(vector prefix %)
                                   m))]
       (->> m
            (fmap bag)
            (map (fn [[k v]]
                   (prefix-keys k v)))
            (into {})))))
